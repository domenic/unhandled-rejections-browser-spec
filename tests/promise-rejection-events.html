<!DOCTYPE html>
<meta charset="utf-8">
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script>
'use strict';

//
// Straightforward unhandledrejection tests
//

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.reject(e);
}, 'unhandledrejection: from Promise.reject');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = new Promise(function(_, reject) {
    reject(e);
  });
}, 'unhandledrejection: from a synchronous rejection in new Promise');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = new Promise(function(_, reject) {
    postMessageTask(function() {
      reject(e);
    });
  });
}, 'unhandledrejection: from a task-delayed rejection');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = new Promise(function(_, reject) {
    setTimeout(function() {
      reject(e);
    }, 1);
  });
}, 'unhandledrejection: from a setTimeout-delayed rejection');

async_test(function(t) {
  var e = new Error();
  var e2 = new Error();
  var promise2;

  onUnhandledSucceed(t, e2, function() { return promise2; });

  var unreached = t.unreached_func('promise should not be fulfilled');
  promise2 = Promise.reject(e).then(unreached, function(reason) {
    t.step(function() {
      assert_equals(reason, e);
    });
    throw e2;
  });
}, 'unhandledrejection: from a throw in a rejection handler chained off of Promise.reject');

async_test(function(t) {
  var e = new Error();
  var e2 = new Error();
  var promise2;

  onUnhandledSucceed(t, e2, function() { return promise2; });

  var unreached = t.unreached_func('promise should not be fulfilled');
  promise2 = new Promise(function(_, reject) {
    setTimeout(function() {
      reject(e);
    }, 1);
  }).then(unreached, function(reason) {
    t.step(function() {
      assert_equals(reason, e);
    });
    throw e2;
  });
}, 'unhandledrejection: from a throw in a rejection handler chained off of a setTimeout-delayed rejection');

async_test(function(t) {
  var e = new Error();
  var e2 = new Error();
  var promise2;

  onUnhandledSucceed(t, e2, function() { return promise2; });

  var promise = new Promise(function(_, reject) {
    setTimeout(function() {
      reject(e);
      mutationObserverMicrotask(function() {
        var unreached = t.unreached_func('promise should not be fulfilled');
        promise2 = promise.then(unreached, function(reason) {
          t.step(function() {
            assert_equals(reason, e);
          });
          throw e2;
        });
      });
    }, 1);
  });
}, 'unhandledrejection: from a throw in a rejection handler attached one microtask after a setTimeout-delayed rejection');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.resolve().then(function() {
    return Promise.reject(e);
  });
}, 'unhandledrejection: from returning a Promise.reject-created rejection in a fulfillment handler');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.resolve().then(function() {
    throw e;
  });
}, 'unhandledrejection: from a throw in a fulfillment handler');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.resolve().then(function() {
    return new Promise(function(_, reject) {
      setTimeout(function() {
        reject(e);
      }, 1);
    });
  });
}, 'unhandledrejection: from returning a setTimeout-delayed rejection in a fulfillment handler');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.all([Promise.reject(e)]);
}, 'unhandledrejection: from Promise.reject, indirected through Promise.all');

//
// Negative unhandledrejection/rejectionhandled tests with immediate attachment
//

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var unreached = t.unreached_func('promise should not be fulfilled');
  Promise.reject(e).then(unreached, function() {});
}, 'no unhandledrejection/rejectionhandled: rejection handler attached synchronously to a promise from Promise.reject');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var unreached = t.unreached_func('promise should not be fulfilled');
  Promise.all([Promise.reject(e)]).then(unreached, function() {});
}, 'no unhandledrejection/rejectionhandled: rejection handler attached synchronously to a promise from ' +
   'Promise.reject, indirecting through Promise.all');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var unreached = t.unreached_func('promise should not be fulfilled');
  new Promise(function(_, reject) {
    reject(e);
  }).then(unreached, function() {});
}, 'no unhandledrejection/rejectionhandled: rejection handler attached synchronously to a synchronously-rejected ' +
   'promise created with new Promise');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var unreached = t.unreached_func('promise should not be fulfilled');
  Promise.resolve().then(function() {
    throw e;
  }).then(unreached, function(reason) {
    t.step(function() {
      assert_equals(reason, e);
    });
  });
}, 'no unhandledrejection/rejectionhandled: rejection handler attached synchronously to a promise created from ' +
   'throwing in a fulfillment handler');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var unreached = t.unreached_func('promise should not be fulfilled');
  Promise.resolve().then(function() {
    return Promise.reject(e);
  }).then(unreached, function(reason) {
    t.step(function() {
      assert_equals(reason, e);
    });
  });
}, 'no unhandledrejection/rejectionhandled: rejection handler attached synchronously to a promise created from ' +
   'returning a Promise.reject-created promise in a fulfillment handler');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var unreached = t.unreached_func('promise should not be fulfilled');
  Promise.resolve().then(function() {
    return new Promise(function(_, reject) {
      setTimeout(function() {
        reject(e);
      }, 1);
    });
  }).then(unreached, function(reason) {
    t.step(function() {
      assert_equals(reason, e);
    });
  });
}, 'no unhandledrejection/rejectionhandled: rejection handler attached synchronously to a promise created from ' +
   'returning a setTimeout-delayed rejection in a fulfillment handler');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  postMessageTask(function() {
    Promise.resolve().then(function() {
      return Promise.reject(e);
    })
    .catch(function() {});
  });
}, 'no unhandledrejection/rejectionhandled: all inside a queued task, a rejection handler attached synchronously to ' +
   'a promise created from returning a Promise.reject-created promise in a fulfillment handler');

//
// Negative unhandledrejection/rejectionhandled tests with delayed attachment
//

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var promise = Promise.reject(e);

  mutationObserverMicrotask(function() {
    var unreached = t.unreached_func('promise should not be fulfilled');
    promise.then(unreached, function() {});
  });
}, 'delayed handling: a microtask delay before attaching a handler prevents both events (Promise.reject-created ' +
   'promise)');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var promise = new Promise(function(_, reject) {
    reject(e);
  });

  mutationObserverMicrotask(function() {
    var unreached = t.unreached_func('promise should not be fulfilled');
    promise.then(unreached, function() {});
  });
}, 'delayed handling: a microtask delay before attaching a handler prevents both events (immediately-rejected new ' +
   'Promise-created promise)');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var p1 = new Promise(function(_, reject) {
    mutationObserverMicrotask(function() {
      reject(e);
    });
  });

  var p2 = Promise.all([1]);
  mutationObserverMicrotask(function() {
    var unreached = t.unreached_func('promise should not be fulfilled');
    p2.then(unreached, function() {});
  });
}, 'delayed handling: a microtask delay before attaching the handler, and before rejecting the promise, indirected ' +
   'through Promise.all');

//
// Negative unhandledrejection/rejectionhandled tests with nested-microtask-delayed attachment
//

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var a = Promise.reject(e);
  mutationObserverMicrotask(function() {
    Promise.resolve().then(function() {
      mutationObserverMicrotask(function() {
        Promise.resolve().then(function() {
          a.catch(function() {});
        });
      });
    });
  });
}, 'microtask nesting: attaching a handler inside a combination of mutationObserverMicrotask + promise microtasks');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  postMessageTask(function() {
    var a = Promise.reject(e);
    mutationObserverMicrotask(function() {
      Promise.resolve().then(function() {
        mutationObserverMicrotask(function() {
          Promise.resolve().then(function() {
            a.catch(function() {});
          });
        });
      });
    });
  });
}, 'microtask nesting: attaching a handler inside a combination of mutationObserverMicrotask + promise microtasks, ' +
   'all inside a postMessageTask');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  setTimeout(function() {
    var a = Promise.reject(e);
    mutationObserverMicrotask(function() {
      Promise.resolve().then(function() {
        mutationObserverMicrotask(function() {
          Promise.resolve().then(function() {
            a.catch(function() {});
          });
        });
      });
    });
  }, 0);
}, 'microtask nesting: attaching a handler inside a combination of mutationObserverMicrotask + promise microtasks, ' +
   'all inside a setTimeout');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  var a = Promise.reject(e);
  Promise.resolve().then(function() {
    mutationObserverMicrotask(function() {
      Promise.resolve().then(function() {
        mutationObserverMicrotask(function() {
          a.catch(function() {});
        });
      });
    });
  });
}, 'microtask nesting: attaching a handler inside a combination of promise microtasks + mutationObserverMicrotask');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  postMessageTask(function() {
    var a = Promise.reject(e);
    Promise.resolve().then(function() {
      mutationObserverMicrotask(function() {
        Promise.resolve().then(function() {
          mutationObserverMicrotask(function() {
            a.catch(function() {});
          });
        });
      });
    });
  });
}, 'microtask nesting: attaching a handler inside a combination of promise microtasks + mutationObserverMicrotask, ' +
   'all inside a postMessageTask');

async_test(function(t) {
  var e = new Error();

  onUnhandledFail(t);

  setTimeout(function() {
    var a = Promise.reject(e);
    Promise.resolve().then(function() {
      mutationObserverMicrotask(function() {
        Promise.resolve().then(function() {
          mutationObserverMicrotask(function() {
            a.catch(function() {});
          });
        });
      });
    });
  }, 0);
}, 'microtask nesting: attaching a handler inside a combination of promise microtasks + mutationObserverMicrotask, ' +
   'all inside a setTimeout');

//
// Positive unhandledrejection/rejectionhandled tests with delayed attachment
//

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  var _reject;
  p = new Promise(function(_, reject) {
    _reject = reject;
  });
  _reject(e);

  postMessageTask(function() {
    var unreached = t.unreached_func('promise should not be fulfilled');
    p.then(unreached, function() {});
  });
}, 'delayed handling: a task delay before attaching a handler does not prevent unhandledrejection');

async_test(function(t) {
  var unhandledPromises = [];
  var unhandledReasons = [];
  var e = new Error();
  var p;

  window.onunhandledrejection = function(ev) {
    t.step(function() {
      unhandledPromises.push(ev.promise);
      unhandledReasons.push(ev.reason);
    });
  };

  window.onrejectionhandled = function(ev) {
    t.step(function() {
      assert_array_equals(unhandledPromises, [p]);
      assert_array_equals(unhandledReasons, [e]);

      assert_equals(ev.promise, p);
      assert_equals(ev.reason, e);
    });
  };

  p = new Promise(function() {
    throw e;
  });

  setTimeout(function() {
    var unreached = t.unreached_func('promise should not be fulfilled');
    p.then(unreached, function(reason) {
      assert_equals(reason, e);
    });
  }, 10);
}, 'delayed handling: delaying handling by setTimeout(,10) will cause both events to fire');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.reject(e);

  postMessageTask(function() {
    Promise.resolve().then(function() {
      p.catch(function() {});
    });
  });
}, 'delayed handling: postMessageTask after promise creation/rejection, plus promise microtasks, is too late to ' +
   'attach a rejection handler');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  postMessageTask(function() {
    Promise.resolve().then(function() {
      Promise.resolve().then(function() {
        Promise.resolve().then(function() {
          Promise.resolve().then(function() {
            p.catch(function() {});
          });
        });
      });
    });
  });

  p = Promise.reject();
}, 'delayed handling: postMessageTask before promise creation/rejection, plus many promise microtasks, is too late ' +
   'to attach a rejection handler');

async_test(function(t) {
  var e = new Error();
  var p;

  onUnhandledSucceed(t, e, function() { return p; });

  p = Promise.reject();

  postMessageTask(function() {
    Promise.resolve().then(function() {
      Promise.resolve().then(function() {
        Promise.resolve().then(function() {
          Promise.resolve().then(function() {
            p.catch(function() {});
          });
        });
      });
    });
  });
}, 'delayed handling: postMessageTask after promise creation/rejection, plus many promise microtasks, is too late ' +
   'to attach a rejection handler');

//
// Miscellaneous tests about integration with the rest of the platform
//

async_test(function(t) {
  var e = new Error();

  window.onunhandledrejection = function(ev) {
    var order = [];

    mutationObserverMicrotask(function() {
      order.push(1);
    });

    setTimeout(function() {
      order.push(2);
      t.step(function() {
        assert_array_equals(order, [1, 2]);
      });
      t.done();
    }, 1);
  };

  ensureCleanup(t);

  Promise.reject(e);
}, 'mutationObserverMicrotask vs. postMessageTask ordering is not disturbed inside unhandledrejection events');



//
// HELPERS
//


function postMessageTask(f) {
  window.onmessage = function() { f(); };
  window.postMessage('abusingpostmessageforfunandprofit', '*');
}

function mutationObserverMicrotask(f) {
  var observer = new MutationObserver(function() { f(); });
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });
  node.data = 'foo';
}

function onUnhandledSucceed(t, expectedReason, expectedPromiseGetter) {
  window.onunhandledrejection = function(ev) {
    t.step(function() {
      assert_equals(ev.reason, expectedReason);
      assert_equals(ev.promise, expectedPromiseGetter());
    });
    t.done();
  };

  ensureCleanup(t);
}

function onUnhandledFail(t) {
  window.onunhandledrejection = t.unreached_func('unhandledrejection event is not supposed to be triggered');
  window.onrejectionhandled = t.unreached_func('rejectionhandled event is not supposed to be triggered');

  ensureCleanup(t);

  setTimeout(function() {
    t.done();
  }, 10);
}

function ensureCleanup(t) {
  t.add_cleanup(function() {
    window.onunhandledrejection = null;
    window.onrejectionhandled = null;
  });
}

</script>
